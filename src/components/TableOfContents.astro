---
// TODO: refactor
// !!! IMPORTANT !!! WARNING !!!
// Very bad code, needs to be refactored
// This code is generated by AI and can work normally(?) after human modification
// Poor quality and difficult to understand
// Don't modify if you are not absolutely sure
// !!! IMPORTANT !!! WARNING !!!


import { type TocItem, TocRenderer } from "./TcoItem";
const renderTocItem = (item: TocItem, index: number) => TocRenderer.renderTocItem(item, index);

export interface Props {
  headings: Array<{
    depth: number;
    text: string;
    slug: string;
  }>;
}

const { headings } = Astro.props;

function buildToc(headings: Props["headings"]): TocItem[] {
  const toc: TocItem[] = [];
  const stack: TocItem[] = [];

  headings.forEach((heading) => {
    const item: TocItem = {
      ...heading,
      children: [],
    };

    // 过滤掉不需要的标题级别(可选)
    if (heading.depth > 4) return;

    if (stack.length === 0) {
      toc.push(item);
      stack.push(item);
      return;
    }

    while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      toc.push(item);
    } else {
      const parent = stack[stack.length - 1];
      parent.children.push(item);
    }

    stack.push(item);
  });

  return toc;
}

const tocItems = buildToc(headings);

// 新增: 计算目录项总数用于显示
const totalHeadings = headings.length;
---

<nav class="toc" aria-label="目录导航" data-total-headings={totalHeadings}>
  <div class="toc-header">
    <div class="search-container">
      <div class="search-input-wrapper">
        <input
          type="search"
          id="toc-search"
          placeholder={`搜索目录(${totalHeadings})...`}
          aria-label="搜索目录"
          autocomplete="off"
        />
        <button type="button" class="clear-search hidden" aria-label="清除搜索"> ✕ </button>
      </div>
      <div class="search-results hidden" role="listbox" aria-label="搜索结果"></div>
    </div>
  </div>

  <div class="toc-content">
    <ul class="toc-list">
      {tocItems.map((item, index) => <Fragment set:html={renderTocItem(item, index)} />)}
    </ul>
  </div>

  <button type="button" class="mobile-toggle" aria-label="切换目录显示" aria-expanded="false">
    <span class="toggle-icon"></span>
    目录
  </button>
</nav>

<script>
  let debounceTimer: NodeJS.Timeout | undefined;
  const DEBOUNCE_DELAY = 150;
  let currentSearchIndex = -1;

  interface ScrollState {
    lastScrollTop: number;
    ticking: boolean;
  }

  const scrollState: ScrollState = {
    lastScrollTop: 0,
    ticking: false,
  };

  // 工具函数：防抖
  function debounce<T extends (...args: any[]) => void>(
    fn: T,
    delay: number,
  ): (...args: Parameters<T>) => void {
    return (...args: Parameters<T>) => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => fn(...args), delay);
    };
  }

  function setupToggleButtons() {
    const toggleButtons = document.querySelectorAll<HTMLButtonElement>(".toggle-btn");

    // 存储展开状态，用于持久化
    const expandedState = new Set<string>(
      JSON.parse(localStorage.getItem("toc-expanded-sections") || "[]"),
    );

    // 初始化展开状态
    expandedState.forEach((index) => {
      const nestedList = document.querySelector(`.nested[data-index="${index}"]`);
      const toggleBtn = document.querySelector(`.toggle-btn[data-index="${index}"]`);

      if (nestedList && toggleBtn) {
        nestedList.classList.remove("collapsed");
        toggleBtn.setAttribute("aria-expanded", "true");

        const expandIcon = toggleBtn.querySelector(".icon-expand");
        const collapseIcon = toggleBtn.querySelector(".icon-collapse");

        expandIcon?.classList.add("hidden");
        collapseIcon?.classList.remove("hidden");
      }
    });

    toggleButtons.forEach((btn) => {
      const index = btn.getAttribute("data-index");
      if (!index) return;

      // 设置初始aria状态
      btn.setAttribute("aria-expanded", expandedState.has(index) ? "true" : "false");

      btn.addEventListener("click", () => {
        const nestedList = document.querySelector(`.nested[data-index="${index}"]`);
        if (!nestedList) return;

        const isExpanding = nestedList.classList.toggle("collapsed");
        const expandIcon = btn.querySelector(".icon-expand");
        const collapseIcon = btn.querySelector(".icon-collapse");

        // 更新展开/收起图标
        if (expandIcon && collapseIcon) {
          expandIcon.classList.toggle("hidden", !isExpanding);
          collapseIcon.classList.toggle("hidden", isExpanding);
        }

        // 更新aria状态
        btn.setAttribute("aria-expanded", (!isExpanding).toString());

        // 更新存储的展开状态
        if (!isExpanding) {
          expandedState.add(index);
        } else {
          expandedState.delete(index);
        }

        // 持久化展开状态
        try {
          localStorage.setItem("toc-expanded-sections", JSON.stringify(Array.from(expandedState)));
        } catch (e) {
          console.warn("Failed to save TOC state:", e);
        }
      });

      // 添加键盘支持
      btn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          btn.click();
        }
      });
    });
  }
  // toc-script.ts
  export function initializeToc() {
    document.addEventListener("DOMContentLoaded", () => {
      const toggleButtons = document.querySelectorAll(".toggle-btn");

      toggleButtons.forEach((button) => {
        if (!(button instanceof HTMLButtonElement)) return;

        button.addEventListener("click", () => {
          const isExpanded = button.getAttribute("aria-expanded") === "true";
          const sectionId = button.getAttribute("aria-controls");

          if (!sectionId) return;

          const section = document.getElementById(sectionId);
          if (!section) return;

          button.setAttribute("aria-expanded", (!isExpanded).toString());
          section.style.display = isExpanded ? "none" : "block";
        });
      });

      // Optional: Add active state for current section
      const updateActiveSection = () => {
        const hash = window.location.hash;
        const allLinks = document.querySelectorAll(".toc-link");

        allLinks.forEach((link) => {
          if (link instanceof HTMLAnchorElement) {
            link.classList.toggle("active", link.getAttribute("href") === hash);
          }
        });
      };

      window.addEventListener("hashchange", updateActiveSection);
      updateActiveSection();
    });
  }
  // 初始化
  function init() {
    setupScrollHandling();
    setupToggleButtons();
    setupSearch();
    setupMobileSupport();
    setupKeyboardNavigation();
    setupResizeHandler();
    initializeToc();
  }

  // 滚动处理优化
  function setupScrollHandling() {
    const tocLinks = document.querySelectorAll<HTMLAnchorElement>(".toc-link");
    const toc = document.querySelector<HTMLElement>(".toc");

    if (!toc) return;

    // 使用 Intersection Observer API 优化滚动性能
    const headingObserver = new IntersectionObserver(
      (entries) => {
        if (scrollState.ticking) return;

        scrollState.ticking = true;
        requestAnimationFrame(() => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) return;

            const id = entry.target.getAttribute("id");
            if (id) updateActiveLink(id);
          });
          scrollState.ticking = false;
        });
      },
      {
        rootMargin: "-100px 0px -66%",
        threshold: [0, 1],
      },
    );

    document
      .querySelectorAll("h1[id], h2[id], h3[id], h4[id]")
      .forEach((heading) => headingObserver.observe(heading));

    // 优化滚动行为
    tocLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const href = link.getAttribute("href");
        if (!href) return;

        const target = document.querySelector(href);
        if (!target) return;

        // 使用更平滑的滚动
        const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - 100;
        window.scrollTo({
          top: targetPosition,
          behavior: "smooth",
        });

        // 更新 URL，但不触发滚动
        history.pushState(null, "", href);

        // 在移动端点击链接后关闭目录
        if (window.innerWidth <= 1024) {
          toc.classList.remove("show");
        }
      });
    });
  }

  function updateActiveLink(id: string) {
    const activeClass = "active";
    document.querySelectorAll(".toc-link").forEach((link) => {
      link.classList.remove(activeClass);
    });

    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
    if (!activeLink) return;

    activeLink.classList.add(activeClass);
    // expandParentSections(activeLink as HTMLElement);
    scrollActiveItemIntoView(activeLink as HTMLElement);
  }

  function scrollActiveItemIntoView(element: HTMLElement) {
    const tocContent = document.querySelector(".toc-content");
    if (!tocContent) return;

    const elementRect = element.getBoundingClientRect();
    const containerRect = tocContent.getBoundingClientRect();

    if (elementRect.bottom > containerRect.bottom || elementRect.top < containerRect.top) {
      element.scrollIntoView({
        behavior: "smooth",
        block: "nearest",
      });
    }
  }

  // 搜索功能增强
  function setupSearch() {
    const searchInput = document.getElementById("toc-search") as HTMLInputElement;
    const searchResults = document.querySelector(".search-results");
    const clearButton = document.querySelector(".clear-search");
    const tocLinks = document.querySelectorAll<HTMLAnchorElement>(".toc-link");

    if (!searchInput || !searchResults || !clearButton) return;

    const handleSearch = debounce(() => {
      const searchTerm = searchInput.value.toLowerCase().trim();
      searchResults.innerHTML = "";
      currentSearchIndex = -1;

      if (searchTerm.length < 2) {
        searchResults.classList.add("hidden");
        clearButton.classList.add("hidden");
        return;
      }

      clearButton.classList.remove("hidden");

      // 改进搜索匹配逻辑
      const matches = Array.from(tocLinks)
        .map((link) => {
          const text = link.textContent?.toLowerCase() || "";
          const score = getSearchScore(text, searchTerm);
          return { link, score };
        })
        .filter((item) => item.score > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);

      if (matches.length > 0) {
        const fragment = document.createDocumentFragment();
        matches.forEach(({ link }) => {
          const div = document.createElement("div");
          div.className = "search-result-item";
          div.textContent = link.textContent;
          div.setAttribute("role", "option");
          div.addEventListener("click", () => {
            link.click();
            resetSearch();
          });
          fragment.appendChild(div);
        });

        searchResults.appendChild(fragment);
        searchResults.classList.remove("hidden");
      } else {
        const noResults = document.createElement("div");
        noResults.className = "search-result-item no-results";
        noResults.textContent = "未找到匹配结果";
        searchResults.appendChild(noResults);
        searchResults.classList.remove("hidden");
      }
    }, DEBOUNCE_DELAY);

    // 搜索评分函数
    function getSearchScore(text: string, searchTerm: string): number {
      if (text === searchTerm) return 100;
      if (text.startsWith(searchTerm)) return 80;
      if (text.includes(searchTerm)) return 60;

      // 支持模糊匹配
      const words = text.split(/\s+/);
      const searchWords = searchTerm.split(/\s+/);

      let score = 0;
      searchWords.forEach((searchWord) => {
        words.forEach((word) => {
          if (word.includes(searchWord)) score += 20;
          else if (word.toLowerCase().includes(searchWord)) score += 10;
        });
      });

      return score;
    }

    function resetSearch() {
      searchInput.value = "";
      searchResults?.classList.add("hidden");
      clearButton?.classList.add("hidden");
      currentSearchIndex = -1;
    }

    // 事件监听器
    searchInput.addEventListener("input", handleSearch);
    clearButton.addEventListener("click", resetSearch);

    // 点击外部关闭搜索结果
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      if (!searchInput.contains(target) && !searchResults.contains(target)) {
        searchResults.classList.add("hidden");
      }
    });
  }

  // 键盘导航支持
  function setupKeyboardNavigation() {
    const searchInput = document.getElementById("toc-search") as HTMLInputElement;
    const searchResults = document.querySelector(".search-results");

    if (!searchInput || !searchResults) return;

    searchInput.addEventListener("keydown", (e) => {
      const items = searchResults.querySelectorAll(".search-result-item");
      if (items.length === 0) return;

      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          navigateSearchResults(1, items);
          break;
        case "ArrowUp":
          e.preventDefault();
          navigateSearchResults(-1, items);
          break;
        case "Enter":
          e.preventDefault();
          if (currentSearchIndex >= 0) {
            (items[currentSearchIndex] as HTMLElement).click();
          }
          break;
        case "Escape":
          e.preventDefault();
          searchResults.classList.add("hidden");
          searchInput.blur();
          break;
      }
    });
  }

  function navigateSearchResults(direction: number, items: NodeListOf<Element>) {
    items[currentSearchIndex]?.classList.remove("keyboard-focus");

    currentSearchIndex += direction;
    if (currentSearchIndex >= items.length) currentSearchIndex = 0;
    if (currentSearchIndex < 0) currentSearchIndex = items.length - 1;

    const currentItem = items[currentSearchIndex] as HTMLElement;
    currentItem.classList.add("keyboard-focus");
    currentItem.scrollIntoView({ block: "nearest" });
  }

  // 移动端支持优化
  function setupMobileSupport() {
    const toc: HTMLElement | null = document.querySelector(".toc");
    const mobileToggle = document.querySelector(".mobile-toggle");

    if (!toc || !mobileToggle) return;

    let touchStartY = 0;
    let touchEndY = 0;
    let isDragging = false;
    let initialTouchY = 0;
    let initialTranslateY = 0;

    const handleTouchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      touchStartY = touch.clientY;
      initialTouchY = touch.clientY;
      isDragging = true;

      const transform = window.getComputedStyle(toc).transform;
      const matrix = new DOMMatrix(transform);
      initialTranslateY = matrix.m42;

      toc.style.transition = "none";
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!isDragging) return;

      const touch = e.touches[0];
      touchEndY = touch.clientY;
      const diff = touchEndY - initialTouchY;

      // 限制拖动范围
      const newTranslateY = Math.max(0, Math.min(initialTranslateY + diff, toc.clientHeight));
      toc.style.transform = `translateY(${newTranslateY}px)`;
    };

    const handleTouchEnd = () => {
      if (!isDragging) return;
      isDragging = false;

      toc.style.transition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
      const diff = touchEndY - touchStartY;

      if (Math.abs(diff) > 50) {
        toc.classList.toggle("show", diff < 0);
        mobileToggle.setAttribute("aria-expanded", diff < 0 ? "true" : "false");
      } else {
        // 恢复原位
        toc.style.transform = `translateY(${initialTranslateY}px)`;
      }
    };

    // 移动端事件监听
    if (window.innerWidth <= 1024) {
      toc.addEventListener("touchstart", handleTouchStart, { passive: true });
      toc.addEventListener("touchmove", handleTouchMove, { passive: true });
      toc.addEventListener("touchend", handleTouchEnd);
      toc.addEventListener("touchcancel", handleTouchEnd);

      // 移动端切换按钮
      mobileToggle.addEventListener("click", () => {
        const isShown = toc.classList.toggle("show");
        mobileToggle.setAttribute("aria-expanded", isShown.toString());
      });
    }
  }

  // 窗口大小调整处理
  function setupResizeHandler() {
    const toc: HTMLElement | null = document.querySelector(".toc");
    if (!toc) return;

    let resizeTimeout: number;

    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() => {
        // 重置移动端状态
        if (window.innerWidth > 1024) {
          toc.classList.remove("show");
          toc.style.transform = "";
        }
      }, 100);
    });
  }

  // 确保 DOM 加载完成后初始化
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
</script>
<style>
  .toc {
    position: sticky;
    top: 2rem;
    width: 260px;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    max-height: calc(100vh - 4rem);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .toc-header {
    padding: 1rem;
    border-bottom: 1px solid #e5e7eb;
  }

  .toc-title-wrapper {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .toc-title {
    font-size: 1.25rem;
    font-weight: 600;
  }

  .toc-count {
    color: #6b7280;
    font-size: 0.875rem;
  }

  .toc-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    scrollbar-gutter: stable;
    overscroll-behavior: contain;
  }
  .toc-list {
    padding: 0;
    margin: 0;
  }

  .search-container {
    position: relative;
  }

  .search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
  }

  #toc-search {
    width: 100%;
    padding: 0.5rem 2rem 0.5rem 0.75rem;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    font-size: 0.875rem;
    transition: all 0.2s;
  }

  #toc-search:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }

  .clear-search {
    position: absolute;
    right: 0.5rem;
    padding: 0.25rem;
    color: #6b7280;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 0.75rem;
    line-height: 1;
  }

  .clear-search:hover {
    color: #374151;
  }

  .search-results {
    position: absolute;
    width: 100%;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    margin-top: 4px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 200px;
    overflow-y: auto;
    z-index: 10;
  }

  .search-result-item {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .search-result-item:hover {
    background-color: #f3f4f6;
  }

  .search-result-item.keyboard-focus {
    background-color: #e5e7eb;
    outline: 2px solid #3b82f6;
  }

  .mobile-toggle {
    display: none;
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    padding: 0.75rem 1rem;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 9999px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    z-index: 50;
    transition: all 0.2s;
  }

  .mobile-toggle:hover {
    background: #2563eb;
  }

  .toggle-icon {
    display: inline-block;
    width: 1rem;
    height: 1rem;
    margin-right: 0.5rem;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='white'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 6h16M4 12h16M4 18h16'/%3E%3C/svg%3E");
  }

  @media (max-width: 768px) {
    .toc {
      position: fixed;
      top: auto;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      max-height: 75vh;
      border-radius: 16px 16px 0 0;
      z-index: 40;
      transform: translateY(100%);
    }

    .toc.show {
      transform: translateY(0);
    }

    .mobile-toggle {
      display: flex;
      align-items: center;
    }

    .toc-header {
      padding: 0.75rem 1rem;
    }

    .toc-content {
      padding: 0.75rem 1rem 1.5rem;
    }
  }

  /* 深色模式支持 */
  /* @media (prefers-color-scheme: dark) {
    .toc {
      background: #1f2937;
      border-color: #374151;
    }

    .toc-header {
      border-color: #374151;
    }

    .toc-title {
      color: #f3f4f6;
    }

    .toc-count {
      color: #9ca3af;
    }

    #toc-search {
      background: #374151;
      border-color: #4b5563;
      color: #f3f4f6;
    }

    #toc-search::placeholder {
      color: #9ca3af;
    }

    .search-results {
      background: #1f2937;
      border-color: #374151;
    }

    .search-result-item:hover {
      background-color: #374151;
    }

    .search-result-item.keyboard-focus {
      background-color: #4b5563;
    }
  } */

  /* toc-styles.css */
  .toc-navigation {
    width: 100%;
    max-width: 300px;
    padding: 16px;
    background-color: #f8f9fa;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .toc-navigation ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc-item-container {
    margin: 4px 0;
  }

  .toc-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .toggle-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    padding: 0;
    background: none;
    border: 1px solid #ccc;
    border-radius: 3px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    color: #666;
  }

  .toggle-btn:hover {
    background-color: #eee;
  }

  .toggle-btn:focus {
    outline: 2px solid #0066cc;
    outline-offset: 2px;
  }

  .toggle-btn .icon-collapse {
    display: none;
  }

  .toggle-btn[aria-expanded="true"] .icon-expand {
    display: none;
  }

  .toggle-btn[aria-expanded="true"] .icon-collapse {
    display: inline;
  }

  .toggle-placeholder {
    width: 20px;
    height: 20px;
  }

  .toc-link {
    text-decoration: none;
    color: #333;
    font-size: 14px;
    line-height: 1.5;
    padding: 4px 0;
  }

  .toc-link:hover {
    color: #0066cc;
  }

  .toc-link:focus {
    outline: 2px solid #0066cc;
    outline-offset: 2px;
  }

  /* Depth indentation */
  .depth-1 {
    margin-left: 0;
  }
  .depth-2 {
    margin-left: 2em;
  }
  .depth-3 {
    margin-left: 4em;
  }
  .depth-4 {
    margin-left: 8em;
  }
  .depth-5 {
    margin-left: 16em;
  }
  .depth-6 {
    margin-left: 32em;
  }

  /* Nested lists */
  .nested {
    display: none;
    /* margin-left: 2em; */
    padding-left: 2em;
  }

  .nested[aria-expanded="true"] {
    display: block;
  }

</style>
